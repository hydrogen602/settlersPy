<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>gameServer.serverCode.factoryAndProtocol API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gameServer.serverCode.factoryAndProtocol</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Tuple, List, Optional, Union, Callable, Dict
import json
from urllib.parse import urlparse, parse_qs

from autobahn.twisted.websocket import WebSocketServerProtocol, WebSocketServerFactory # type: ignore
from autobahn.websocket.protocol import ConnectingRequest, ConnectionDeny
from twisted.python import log # type: ignore
from twisted.internet import reactor # type: ignore

from .. import playerCode
from .. import game


class ServerProtocol(WebSocketServerProtocol):
    &#39;&#39;&#39;
    Sending a message of &#39;Hi&#39; returns two messages, &#39;Hello&#39; and a json
    that is {&#39;token&#39;: token}

    Sending a message of &#39;history&#39; returns all previously send messages
    &#39;&#39;&#39;

    @property
    def token(self) -&gt; Optional[str]:
        try:
            return self.__token
        except AttributeError:
            return None
    
    @property
    def isOpen(self) -&gt; bool:
        try:
            return self.__isOpen
        except AttributeError:
            return False

    def onConnect(self, request: ConnectingRequest):

        print(request.path)
        # print(request.headers)
        # print(request.protocols)

        # debug information
        print(&#39;Client connecting &amp; registering: {0}&#39;.format(request.peer))
        clientTypeRequest = request.path

        # process the type of request
        if clientTypeRequest.startswith(&#39;/&#39;):
            # remove the slash if there is one
            clientTypeRequest = clientTypeRequest[1:]

        # tell the factory to remember the connection
        self.__token = self.factory.register(self, clientTypeRequest) # pylint: disable=no-member

    def onOpen(self):
        print(&#39;WebSocket connection open&#39;)
        self.__isOpen = True

    def onClose(self, wasClean, code, reason):
        print(&#39;WebSocket connection closed: {0}&#39;.format(reason))
        self.__isOpen = False

        # tell the factory that this connection is dead
        self.factory.unregister(self) # pylint: disable=no-member

    def onMessage(self, msg, isBinary):
        msg = msg.decode()

        if msg.lower() == &#39;hi&#39;:
            self.sendMessage(b&#34;Hello&#34;)

            msg = json.dumps({&#39;token&#39;: self.factory.getToken(self)}) # pylint: disable=no-member
            self.sendMessage(msg.encode())

        elif msg == &#39;history&#39;:
            self.factory.sendHistory(self) # pylint: disable=no-member

        else:
            try:
                obj = json.loads(msg)
                if type(obj) == &#39;str&#39;:
                    raise json.decoder.JSONDecodeError

                print(&#34;Got json msg:&#34;, obj)

                self.factory.onMessage(obj, self) # pylint: disable=no-member
                #m = Message(mechanics.PlayerManager.instance.getPlayer(self.token), obj, self.factory)

                #self.factory.callbackHandler(m, self)   
            except json.decoder.JSONDecodeError:
                print(&#34;Error: Invalid JSON:&#34;, msg)
    
    def sendMessage(self, payload: Union[str, bytes], isBinary=False, fragmentSize=None, sync=False, doNotCompress=False):
        if isinstance(payload, str):
            payload = payload.encode()
        return super().sendMessage(payload, isBinary=isBinary, fragmentSize=fragmentSize, sync=sync, doNotCompress=doNotCompress)


class ServerFactory(WebSocketServerFactory):
    &#39;&#39;&#39;
    Keeps track of all connections and relays data to other clients
    &#39;&#39;&#39;

    def __init__(self, url, f, g: game.Game, serverCallback: Callable[[dict, ServerProtocol], None]):
        &#39;&#39;&#39;
        Initializes the class
        Args:
            url (str): has to be in the format of &#34;ws://127.0.0.1:8008&#34;
            f (file): a writable file for logging
        
        The playerManager should be shared with the GameManager
        &#39;&#39;&#39;

        self.g: game.Game = g
        self.playerManager: playerCode.PlayerManager = g.playerManager

        self.file = f

        self.history = [g.getAsJson()]

        self.serverCallback = serverCallback

        WebSocketServerFactory.__init__(self, url)
    
    def getToken(self, client: ServerProtocol) -&gt; str:
        t = client.token
        if t is None:
            raise Exception(&#39;client has not yet registered. This error should not occur ever&#39;)

        return t
    
    def sendHistory(self, client):
        for msg in self.history:
            client.sendMessage(msg.encode())
        client.sendMessage(self.g.getAsJson()) # latest state of the board
    
    def onMessage(self, obj: dict, client: ServerProtocol):
        self.serverCallback(obj, client)

    def register(self, client: ServerProtocol, clientTypeRequest: str) -&gt; Optional[str]:
        &#39;&#39;&#39;
        Called by any new connecting client to address
        whether they are a new player or a reconnecting one.

        The request line should be /name/token
        or /name but the first / is removed by onConnect

        In the case that the name is missing the method will
        return `None` and trigger a 400 error. Same goes for if
        a token is given that the server does not know.        
        &#39;&#39;&#39;
        token: Optional[str] = None
        name: Optional[str] = None

        # parsed = urlparse(clientTypeRequest)

        # if parsed.path == &#39;login&#39;:
        #     query: Dict[str, List[str]] = parse_qs(parsed.query)
        #     if not &#39;name&#39; in query or len(query[&#39;name&#39;]) != 1:
        #         print(&#39;name missing&#39;)
        #         client.sendHttpErrorResponse(404, &#39;Name missing&#39;)
        #         #client.sendClose()
        #         return None
            
        #     name = query[&#39;name&#39;][0]
            
        #     if &#39;token&#39; in query or len(query[&#39;token&#39;]) == 1:
        #         token = query[&#39;token&#39;][0]
        # else:

        if len(clientTypeRequest.strip()) == 0:
            print(&#39;name missing&#39;)
            client.sendHttpErrorResponse(404, &#39;Name missing&#39;)
            #client.sendClose()
            return None

        
        tmp: str = clientTypeRequest.strip()
        tmpLs = tmp.split(&#39;/&#39;)
        del tmp

        l = len(tmpLs)
        if l == 1:
            name = tmpLs[0]
        elif l == 2:
            name = tmpLs[0]
            token = tmpLs[1]
        else:
            print(&#39;name missing&#39;)
            client.sendHttpErrorResponse(404, &#39;Name missing&#39;)
            #client.sendClose()
            return None
        
        # print(&#39;clientTypeRequest =&#39;, len(clientTypeRequest.strip().split(&#39;/&#39;)))

        if name is None:
            raise RuntimeError(&#34;Something went wrong in register&#34;)
        
        if token is None:
            if self.g.playerManager.isGameStarted():
                print(&#39;game already started, can\&#39;t join&#39;)
                client.sendHttpErrorResponse(403, &#39;Game already started, can\&#39;t join&#39;)
                return None
            
            p: playerCode.Player = playerCode.Player(name, client, color=&#39;green&#39;)
            print(&#34;New player:&#34;, p)
            self.g.addPlayer(p)
            self.newNotificationToAll(&#39;New Player: &#39; + p.name)

            return p.token

        else:
            if token in self.playerManager:
                print(&#34;Reconnecting player:&#34;, token)
                p = self.playerManager[token]
                p.reconnect(client)
                self.newNotificationToAll(f&#39;{p.name} reconnected&#39;)
            else:
                print(&#34;Unknown token:&#34;, token)
                client.sendHttpErrorResponse(403, &#39;Unknown token given&#39;)
                #client.sendClose()
                return None
        
            return p.token

    def unregister(self, client: ServerProtocol):
        token = client.token
        if token is None:
            print(&#34;Player disconnected before assigned token:&#34;, token)
        elif token in self.playerManager:
            print(&#34;Disconnected player:&#34;, token)
            self.newNotificationToAll(f&#39;{self.playerManager[token].name} disconnected&#39;)
            self.playerManager[token].disconnect()            
        else:
            print(&#34;Disconnected player, but token not found?:&#34;, token)
    
    def newNotificationToAll(self, msg: str):
        json_msg = { &#39;type&#39;: &#39;notification&#39;, &#39;content&#39;: msg }
        # special messages have a type and content
        self.broadcastToAll(json.dumps(json_msg))
    
    def broadcastToAll(self, msg: str): # sourceConnection: ServerProtocol
        &#39;&#39;&#39;
        Sends a message of type `str` to all currently connected
        players
        &#39;&#39;&#39;
        self.file.write(msg + &#39;\n&#39;)
        self.file.flush()
        self.history.append(msg)

        encoded = msg.encode()

        for p in self.playerManager:
            if p.isConnected() and p.connection.isOpen:
                p.connection.sendMessage(encoded)
    
    def broadcastToSome(self, msg: str, tokenList: List[str], writeToHistory: bool = False):
        &#39;&#39;&#39;
        Sends a message of type `str` to all currently connected
        players whose token is found in the list.
        `writeToHistory`  determines whether or not this message should
        be included in the history.
        &#39;&#39;&#39;
        if writeToHistory:
            self.file.write(msg + &#39;\n&#39;)
            self.file.flush()
            self.history.append(msg)
        
        encoded = msg.encode()
        
        for token in tokenList:
            p = self.playerManager.getPlayer(token)
            if p is not None and p.isConnected() and p.connection.isOpen:
                p.connection.sendMessage(encoded)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gameServer.serverCode.factoryAndProtocol.ServerFactory"><code class="flex name class">
<span>class <span class="ident">ServerFactory</span></span>
<span>(</span><span>url, f, g, serverCallback)</span>
</code></dt>
<dd>
<section class="desc"><p>Keeps track of all connections and relays data to other clients</p>
<p>Initializes the class</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>has to be in the format of "ws://127.0.0.1:8008"</dd>
<dt><strong><code>f</code></strong> :&ensp;<code>file</code></dt>
<dd>a writable file for logging</dd>
</dl>
<p>The playerManager should be shared with the GameManager</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServerFactory(WebSocketServerFactory):
    &#39;&#39;&#39;
    Keeps track of all connections and relays data to other clients
    &#39;&#39;&#39;

    def __init__(self, url, f, g: game.Game, serverCallback: Callable[[dict, ServerProtocol], None]):
        &#39;&#39;&#39;
        Initializes the class
        Args:
            url (str): has to be in the format of &#34;ws://127.0.0.1:8008&#34;
            f (file): a writable file for logging
        
        The playerManager should be shared with the GameManager
        &#39;&#39;&#39;

        self.g: game.Game = g
        self.playerManager: playerCode.PlayerManager = g.playerManager

        self.file = f

        self.history = [g.getAsJson()]

        self.serverCallback = serverCallback

        WebSocketServerFactory.__init__(self, url)
    
    def getToken(self, client: ServerProtocol) -&gt; str:
        t = client.token
        if t is None:
            raise Exception(&#39;client has not yet registered. This error should not occur ever&#39;)

        return t
    
    def sendHistory(self, client):
        for msg in self.history:
            client.sendMessage(msg.encode())
        client.sendMessage(self.g.getAsJson()) # latest state of the board
    
    def onMessage(self, obj: dict, client: ServerProtocol):
        self.serverCallback(obj, client)

    def register(self, client: ServerProtocol, clientTypeRequest: str) -&gt; Optional[str]:
        &#39;&#39;&#39;
        Called by any new connecting client to address
        whether they are a new player or a reconnecting one.

        The request line should be /name/token
        or /name but the first / is removed by onConnect

        In the case that the name is missing the method will
        return `None` and trigger a 400 error. Same goes for if
        a token is given that the server does not know.        
        &#39;&#39;&#39;
        token: Optional[str] = None
        name: Optional[str] = None

        # parsed = urlparse(clientTypeRequest)

        # if parsed.path == &#39;login&#39;:
        #     query: Dict[str, List[str]] = parse_qs(parsed.query)
        #     if not &#39;name&#39; in query or len(query[&#39;name&#39;]) != 1:
        #         print(&#39;name missing&#39;)
        #         client.sendHttpErrorResponse(404, &#39;Name missing&#39;)
        #         #client.sendClose()
        #         return None
            
        #     name = query[&#39;name&#39;][0]
            
        #     if &#39;token&#39; in query or len(query[&#39;token&#39;]) == 1:
        #         token = query[&#39;token&#39;][0]
        # else:

        if len(clientTypeRequest.strip()) == 0:
            print(&#39;name missing&#39;)
            client.sendHttpErrorResponse(404, &#39;Name missing&#39;)
            #client.sendClose()
            return None

        
        tmp: str = clientTypeRequest.strip()
        tmpLs = tmp.split(&#39;/&#39;)
        del tmp

        l = len(tmpLs)
        if l == 1:
            name = tmpLs[0]
        elif l == 2:
            name = tmpLs[0]
            token = tmpLs[1]
        else:
            print(&#39;name missing&#39;)
            client.sendHttpErrorResponse(404, &#39;Name missing&#39;)
            #client.sendClose()
            return None
        
        # print(&#39;clientTypeRequest =&#39;, len(clientTypeRequest.strip().split(&#39;/&#39;)))

        if name is None:
            raise RuntimeError(&#34;Something went wrong in register&#34;)
        
        if token is None:
            if self.g.playerManager.isGameStarted():
                print(&#39;game already started, can\&#39;t join&#39;)
                client.sendHttpErrorResponse(403, &#39;Game already started, can\&#39;t join&#39;)
                return None
            
            p: playerCode.Player = playerCode.Player(name, client, color=&#39;green&#39;)
            print(&#34;New player:&#34;, p)
            self.g.addPlayer(p)
            self.newNotificationToAll(&#39;New Player: &#39; + p.name)

            return p.token

        else:
            if token in self.playerManager:
                print(&#34;Reconnecting player:&#34;, token)
                p = self.playerManager[token]
                p.reconnect(client)
                self.newNotificationToAll(f&#39;{p.name} reconnected&#39;)
            else:
                print(&#34;Unknown token:&#34;, token)
                client.sendHttpErrorResponse(403, &#39;Unknown token given&#39;)
                #client.sendClose()
                return None
        
            return p.token

    def unregister(self, client: ServerProtocol):
        token = client.token
        if token is None:
            print(&#34;Player disconnected before assigned token:&#34;, token)
        elif token in self.playerManager:
            print(&#34;Disconnected player:&#34;, token)
            self.newNotificationToAll(f&#39;{self.playerManager[token].name} disconnected&#39;)
            self.playerManager[token].disconnect()            
        else:
            print(&#34;Disconnected player, but token not found?:&#34;, token)
    
    def newNotificationToAll(self, msg: str):
        json_msg = { &#39;type&#39;: &#39;notification&#39;, &#39;content&#39;: msg }
        # special messages have a type and content
        self.broadcastToAll(json.dumps(json_msg))
    
    def broadcastToAll(self, msg: str): # sourceConnection: ServerProtocol
        &#39;&#39;&#39;
        Sends a message of type `str` to all currently connected
        players
        &#39;&#39;&#39;
        self.file.write(msg + &#39;\n&#39;)
        self.file.flush()
        self.history.append(msg)

        encoded = msg.encode()

        for p in self.playerManager:
            if p.isConnected() and p.connection.isOpen:
                p.connection.sendMessage(encoded)
    
    def broadcastToSome(self, msg: str, tokenList: List[str], writeToHistory: bool = False):
        &#39;&#39;&#39;
        Sends a message of type `str` to all currently connected
        players whose token is found in the list.
        `writeToHistory`  determines whether or not this message should
        be included in the history.
        &#39;&#39;&#39;
        if writeToHistory:
            self.file.write(msg + &#39;\n&#39;)
            self.file.flush()
            self.history.append(msg)
        
        encoded = msg.encode()
        
        for token in tokenList:
            p = self.playerManager.getPlayer(token)
            if p is not None and p.isConnected() and p.connection.isOpen:
                p.connection.sendMessage(encoded)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>autobahn.twisted.websocket.WebSocketServerFactory</li>
<li>autobahn.twisted.websocket.WebSocketAdapterFactory</li>
<li>autobahn.websocket.protocol.WebSocketServerFactory</li>
<li>autobahn.websocket.protocol.WebSocketFactory</li>
<li>twisted.internet.protocol.ServerFactory</li>
<li>twisted.internet.protocol.Factory</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gameServer.serverCode.factoryAndProtocol.ServerFactory.broadcastToAll"><code class="name flex">
<span>def <span class="ident">broadcastToAll</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<section class="desc"><p>Sends a message of type <code>str</code> to all currently connected
players</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def broadcastToAll(self, msg: str): # sourceConnection: ServerProtocol
    &#39;&#39;&#39;
    Sends a message of type `str` to all currently connected
    players
    &#39;&#39;&#39;
    self.file.write(msg + &#39;\n&#39;)
    self.file.flush()
    self.history.append(msg)

    encoded = msg.encode()

    for p in self.playerManager:
        if p.isConnected() and p.connection.isOpen:
            p.connection.sendMessage(encoded)</code></pre>
</details>
</dd>
<dt id="gameServer.serverCode.factoryAndProtocol.ServerFactory.broadcastToSome"><code class="name flex">
<span>def <span class="ident">broadcastToSome</span></span>(<span>self, msg, tokenList, writeToHistory=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Sends a message of type <code>str</code> to all currently connected
players whose token is found in the list.
<code>writeToHistory</code>
determines whether or not this message should
be included in the history.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def broadcastToSome(self, msg: str, tokenList: List[str], writeToHistory: bool = False):
    &#39;&#39;&#39;
    Sends a message of type `str` to all currently connected
    players whose token is found in the list.
    `writeToHistory`  determines whether or not this message should
    be included in the history.
    &#39;&#39;&#39;
    if writeToHistory:
        self.file.write(msg + &#39;\n&#39;)
        self.file.flush()
        self.history.append(msg)
    
    encoded = msg.encode()
    
    for token in tokenList:
        p = self.playerManager.getPlayer(token)
        if p is not None and p.isConnected() and p.connection.isOpen:
            p.connection.sendMessage(encoded)</code></pre>
</details>
</dd>
<dt id="gameServer.serverCode.factoryAndProtocol.ServerFactory.getToken"><code class="name flex">
<span>def <span class="ident">getToken</span></span>(<span>self, client)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getToken(self, client: ServerProtocol) -&gt; str:
    t = client.token
    if t is None:
        raise Exception(&#39;client has not yet registered. This error should not occur ever&#39;)

    return t</code></pre>
</details>
</dd>
<dt id="gameServer.serverCode.factoryAndProtocol.ServerFactory.newNotificationToAll"><code class="name flex">
<span>def <span class="ident">newNotificationToAll</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newNotificationToAll(self, msg: str):
    json_msg = { &#39;type&#39;: &#39;notification&#39;, &#39;content&#39;: msg }
    # special messages have a type and content
    self.broadcastToAll(json.dumps(json_msg))</code></pre>
</details>
</dd>
<dt id="gameServer.serverCode.factoryAndProtocol.ServerFactory.onMessage"><code class="name flex">
<span>def <span class="ident">onMessage</span></span>(<span>self, obj, client)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onMessage(self, obj: dict, client: ServerProtocol):
    self.serverCallback(obj, client)</code></pre>
</details>
</dd>
<dt id="gameServer.serverCode.factoryAndProtocol.ServerFactory.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>self, client, clientTypeRequest)</span>
</code></dt>
<dd>
<section class="desc"><p>Called by any new connecting client to address
whether they are a new player or a reconnecting one.</p>
<p>The request line should be /name/token
or /name but the first / is removed by onConnect</p>
<p>In the case that the name is missing the method will
return <code>None</code> and trigger a 400 error. Same goes for if
a token is given that the server does not know.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register(self, client: ServerProtocol, clientTypeRequest: str) -&gt; Optional[str]:
    &#39;&#39;&#39;
    Called by any new connecting client to address
    whether they are a new player or a reconnecting one.

    The request line should be /name/token
    or /name but the first / is removed by onConnect

    In the case that the name is missing the method will
    return `None` and trigger a 400 error. Same goes for if
    a token is given that the server does not know.        
    &#39;&#39;&#39;
    token: Optional[str] = None
    name: Optional[str] = None

    # parsed = urlparse(clientTypeRequest)

    # if parsed.path == &#39;login&#39;:
    #     query: Dict[str, List[str]] = parse_qs(parsed.query)
    #     if not &#39;name&#39; in query or len(query[&#39;name&#39;]) != 1:
    #         print(&#39;name missing&#39;)
    #         client.sendHttpErrorResponse(404, &#39;Name missing&#39;)
    #         #client.sendClose()
    #         return None
        
    #     name = query[&#39;name&#39;][0]
        
    #     if &#39;token&#39; in query or len(query[&#39;token&#39;]) == 1:
    #         token = query[&#39;token&#39;][0]
    # else:

    if len(clientTypeRequest.strip()) == 0:
        print(&#39;name missing&#39;)
        client.sendHttpErrorResponse(404, &#39;Name missing&#39;)
        #client.sendClose()
        return None

    
    tmp: str = clientTypeRequest.strip()
    tmpLs = tmp.split(&#39;/&#39;)
    del tmp

    l = len(tmpLs)
    if l == 1:
        name = tmpLs[0]
    elif l == 2:
        name = tmpLs[0]
        token = tmpLs[1]
    else:
        print(&#39;name missing&#39;)
        client.sendHttpErrorResponse(404, &#39;Name missing&#39;)
        #client.sendClose()
        return None
    
    # print(&#39;clientTypeRequest =&#39;, len(clientTypeRequest.strip().split(&#39;/&#39;)))

    if name is None:
        raise RuntimeError(&#34;Something went wrong in register&#34;)
    
    if token is None:
        if self.g.playerManager.isGameStarted():
            print(&#39;game already started, can\&#39;t join&#39;)
            client.sendHttpErrorResponse(403, &#39;Game already started, can\&#39;t join&#39;)
            return None
        
        p: playerCode.Player = playerCode.Player(name, client, color=&#39;green&#39;)
        print(&#34;New player:&#34;, p)
        self.g.addPlayer(p)
        self.newNotificationToAll(&#39;New Player: &#39; + p.name)

        return p.token

    else:
        if token in self.playerManager:
            print(&#34;Reconnecting player:&#34;, token)
            p = self.playerManager[token]
            p.reconnect(client)
            self.newNotificationToAll(f&#39;{p.name} reconnected&#39;)
        else:
            print(&#34;Unknown token:&#34;, token)
            client.sendHttpErrorResponse(403, &#39;Unknown token given&#39;)
            #client.sendClose()
            return None
    
        return p.token</code></pre>
</details>
</dd>
<dt id="gameServer.serverCode.factoryAndProtocol.ServerFactory.sendHistory"><code class="name flex">
<span>def <span class="ident">sendHistory</span></span>(<span>self, client)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sendHistory(self, client):
    for msg in self.history:
        client.sendMessage(msg.encode())
    client.sendMessage(self.g.getAsJson()) # latest state of the board</code></pre>
</details>
</dd>
<dt id="gameServer.serverCode.factoryAndProtocol.ServerFactory.unregister"><code class="name flex">
<span>def <span class="ident">unregister</span></span>(<span>self, client)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister(self, client: ServerProtocol):
    token = client.token
    if token is None:
        print(&#34;Player disconnected before assigned token:&#34;, token)
    elif token in self.playerManager:
        print(&#34;Disconnected player:&#34;, token)
        self.newNotificationToAll(f&#39;{self.playerManager[token].name} disconnected&#39;)
        self.playerManager[token].disconnect()            
    else:
        print(&#34;Disconnected player, but token not found?:&#34;, token)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gameServer.serverCode.factoryAndProtocol.ServerProtocol"><code class="flex name class">
<span>class <span class="ident">ServerProtocol</span></span>
</code></dt>
<dd>
<section class="desc"><p>Sending a message of 'Hi' returns two messages, 'Hello' and a json
that is {'token': token}</p>
<p>Sending a message of 'history' returns all previously send messages</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServerProtocol(WebSocketServerProtocol):
    &#39;&#39;&#39;
    Sending a message of &#39;Hi&#39; returns two messages, &#39;Hello&#39; and a json
    that is {&#39;token&#39;: token}

    Sending a message of &#39;history&#39; returns all previously send messages
    &#39;&#39;&#39;

    @property
    def token(self) -&gt; Optional[str]:
        try:
            return self.__token
        except AttributeError:
            return None
    
    @property
    def isOpen(self) -&gt; bool:
        try:
            return self.__isOpen
        except AttributeError:
            return False

    def onConnect(self, request: ConnectingRequest):

        print(request.path)
        # print(request.headers)
        # print(request.protocols)

        # debug information
        print(&#39;Client connecting &amp; registering: {0}&#39;.format(request.peer))
        clientTypeRequest = request.path

        # process the type of request
        if clientTypeRequest.startswith(&#39;/&#39;):
            # remove the slash if there is one
            clientTypeRequest = clientTypeRequest[1:]

        # tell the factory to remember the connection
        self.__token = self.factory.register(self, clientTypeRequest) # pylint: disable=no-member

    def onOpen(self):
        print(&#39;WebSocket connection open&#39;)
        self.__isOpen = True

    def onClose(self, wasClean, code, reason):
        print(&#39;WebSocket connection closed: {0}&#39;.format(reason))
        self.__isOpen = False

        # tell the factory that this connection is dead
        self.factory.unregister(self) # pylint: disable=no-member

    def onMessage(self, msg, isBinary):
        msg = msg.decode()

        if msg.lower() == &#39;hi&#39;:
            self.sendMessage(b&#34;Hello&#34;)

            msg = json.dumps({&#39;token&#39;: self.factory.getToken(self)}) # pylint: disable=no-member
            self.sendMessage(msg.encode())

        elif msg == &#39;history&#39;:
            self.factory.sendHistory(self) # pylint: disable=no-member

        else:
            try:
                obj = json.loads(msg)
                if type(obj) == &#39;str&#39;:
                    raise json.decoder.JSONDecodeError

                print(&#34;Got json msg:&#34;, obj)

                self.factory.onMessage(obj, self) # pylint: disable=no-member
                #m = Message(mechanics.PlayerManager.instance.getPlayer(self.token), obj, self.factory)

                #self.factory.callbackHandler(m, self)   
            except json.decoder.JSONDecodeError:
                print(&#34;Error: Invalid JSON:&#34;, msg)
    
    def sendMessage(self, payload: Union[str, bytes], isBinary=False, fragmentSize=None, sync=False, doNotCompress=False):
        if isinstance(payload, str):
            payload = payload.encode()
        return super().sendMessage(payload, isBinary=isBinary, fragmentSize=fragmentSize, sync=sync, doNotCompress=doNotCompress)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>autobahn.twisted.websocket.WebSocketServerProtocol</li>
<li>autobahn.twisted.websocket.WebSocketAdapterProtocol</li>
<li>twisted.internet.protocol.Protocol</li>
<li>twisted.internet.protocol.BaseProtocol</li>
<li>autobahn.websocket.protocol.WebSocketServerProtocol</li>
<li>autobahn.websocket.protocol.WebSocketProtocol</li>
<li>autobahn.util.ObservableMixin</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="gameServer.serverCode.factoryAndProtocol.ServerProtocol.isOpen"><code class="name">var <span class="ident">isOpen</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def isOpen(self) -&gt; bool:
    try:
        return self.__isOpen
    except AttributeError:
        return False</code></pre>
</details>
</dd>
<dt id="gameServer.serverCode.factoryAndProtocol.ServerProtocol.token"><code class="name">var <span class="ident">token</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def token(self) -&gt; Optional[str]:
    try:
        return self.__token
    except AttributeError:
        return None</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gameServer.serverCode.factoryAndProtocol.ServerProtocol.onClose"><code class="name flex">
<span>def <span class="ident">onClose</span></span>(<span>self, wasClean, code, reason)</span>
</code></dt>
<dd>
<section class="desc"><p>Implements :func:<code>autobahn.websocket.interfaces.IWebSocketChannel.onClose</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onClose(self, wasClean, code, reason):
    print(&#39;WebSocket connection closed: {0}&#39;.format(reason))
    self.__isOpen = False

    # tell the factory that this connection is dead
    self.factory.unregister(self) # pylint: disable=no-member</code></pre>
</details>
</dd>
<dt id="gameServer.serverCode.factoryAndProtocol.ServerProtocol.onConnect"><code class="name flex">
<span>def <span class="ident">onConnect</span></span>(<span>self, request)</span>
</code></dt>
<dd>
<section class="desc"><p>Callback fired during WebSocket opening handshake when new WebSocket client
connection is about to be established.</p>
<p>When you want to accept the connection, return the accepted protocol
from list of WebSocket (sub)protocols provided by client or <code>None</code> to
speak no specific one or when the client protocol list was empty.</p>
<p>You may also return a pair of <code>(protocol, headers)</code> to send additional
HTTP headers, with <code>headers</code> being a dictionary of key-values.</p>
<p>Throw :class:<code>autobahn.websocket.types.ConnectionDeny</code> when you don't want
to accept the WebSocket connection request.</p>
<p>:param request: WebSocket connection request information.
:type request: instance of :class:<code>autobahn.websocket.protocol.ConnectionRequest</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onConnect(self, request: ConnectingRequest):

    print(request.path)
    # print(request.headers)
    # print(request.protocols)

    # debug information
    print(&#39;Client connecting &amp; registering: {0}&#39;.format(request.peer))
    clientTypeRequest = request.path

    # process the type of request
    if clientTypeRequest.startswith(&#39;/&#39;):
        # remove the slash if there is one
        clientTypeRequest = clientTypeRequest[1:]

    # tell the factory to remember the connection
    self.__token = self.factory.register(self, clientTypeRequest) # pylint: disable=no-member</code></pre>
</details>
</dd>
<dt id="gameServer.serverCode.factoryAndProtocol.ServerProtocol.onMessage"><code class="name flex">
<span>def <span class="ident">onMessage</span></span>(<span>self, msg, isBinary)</span>
</code></dt>
<dd>
<section class="desc"><p>Implements :func:<code>autobahn.websocket.interfaces.IWebSocketChannel.onMessage</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onMessage(self, msg, isBinary):
    msg = msg.decode()

    if msg.lower() == &#39;hi&#39;:
        self.sendMessage(b&#34;Hello&#34;)

        msg = json.dumps({&#39;token&#39;: self.factory.getToken(self)}) # pylint: disable=no-member
        self.sendMessage(msg.encode())

    elif msg == &#39;history&#39;:
        self.factory.sendHistory(self) # pylint: disable=no-member

    else:
        try:
            obj = json.loads(msg)
            if type(obj) == &#39;str&#39;:
                raise json.decoder.JSONDecodeError

            print(&#34;Got json msg:&#34;, obj)

            self.factory.onMessage(obj, self) # pylint: disable=no-member
            #m = Message(mechanics.PlayerManager.instance.getPlayer(self.token), obj, self.factory)

            #self.factory.callbackHandler(m, self)   
        except json.decoder.JSONDecodeError:
            print(&#34;Error: Invalid JSON:&#34;, msg)</code></pre>
</details>
</dd>
<dt id="gameServer.serverCode.factoryAndProtocol.ServerProtocol.onOpen"><code class="name flex">
<span>def <span class="ident">onOpen</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Implements :func:<code>autobahn.websocket.interfaces.IWebSocketChannel.onOpen</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onOpen(self):
    print(&#39;WebSocket connection open&#39;)
    self.__isOpen = True</code></pre>
</details>
</dd>
<dt id="gameServer.serverCode.factoryAndProtocol.ServerProtocol.sendMessage"><code class="name flex">
<span>def <span class="ident">sendMessage</span></span>(<span>self, payload, isBinary=False, fragmentSize=None, sync=False, doNotCompress=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Implements :func:<code>autobahn.websocket.interfaces.IWebSocketChannel.sendMessage</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sendMessage(self, payload: Union[str, bytes], isBinary=False, fragmentSize=None, sync=False, doNotCompress=False):
    if isinstance(payload, str):
        payload = payload.encode()
    return super().sendMessage(payload, isBinary=isBinary, fragmentSize=fragmentSize, sync=sync, doNotCompress=doNotCompress)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gameServer.serverCode" href="index.html">gameServer.serverCode</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gameServer.serverCode.factoryAndProtocol.ServerFactory" href="#gameServer.serverCode.factoryAndProtocol.ServerFactory">ServerFactory</a></code></h4>
<ul class="">
<li><code><a title="gameServer.serverCode.factoryAndProtocol.ServerFactory.broadcastToAll" href="#gameServer.serverCode.factoryAndProtocol.ServerFactory.broadcastToAll">broadcastToAll</a></code></li>
<li><code><a title="gameServer.serverCode.factoryAndProtocol.ServerFactory.broadcastToSome" href="#gameServer.serverCode.factoryAndProtocol.ServerFactory.broadcastToSome">broadcastToSome</a></code></li>
<li><code><a title="gameServer.serverCode.factoryAndProtocol.ServerFactory.getToken" href="#gameServer.serverCode.factoryAndProtocol.ServerFactory.getToken">getToken</a></code></li>
<li><code><a title="gameServer.serverCode.factoryAndProtocol.ServerFactory.newNotificationToAll" href="#gameServer.serverCode.factoryAndProtocol.ServerFactory.newNotificationToAll">newNotificationToAll</a></code></li>
<li><code><a title="gameServer.serverCode.factoryAndProtocol.ServerFactory.onMessage" href="#gameServer.serverCode.factoryAndProtocol.ServerFactory.onMessage">onMessage</a></code></li>
<li><code><a title="gameServer.serverCode.factoryAndProtocol.ServerFactory.register" href="#gameServer.serverCode.factoryAndProtocol.ServerFactory.register">register</a></code></li>
<li><code><a title="gameServer.serverCode.factoryAndProtocol.ServerFactory.sendHistory" href="#gameServer.serverCode.factoryAndProtocol.ServerFactory.sendHistory">sendHistory</a></code></li>
<li><code><a title="gameServer.serverCode.factoryAndProtocol.ServerFactory.unregister" href="#gameServer.serverCode.factoryAndProtocol.ServerFactory.unregister">unregister</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gameServer.serverCode.factoryAndProtocol.ServerProtocol" href="#gameServer.serverCode.factoryAndProtocol.ServerProtocol">ServerProtocol</a></code></h4>
<ul class="two-column">
<li><code><a title="gameServer.serverCode.factoryAndProtocol.ServerProtocol.isOpen" href="#gameServer.serverCode.factoryAndProtocol.ServerProtocol.isOpen">isOpen</a></code></li>
<li><code><a title="gameServer.serverCode.factoryAndProtocol.ServerProtocol.onClose" href="#gameServer.serverCode.factoryAndProtocol.ServerProtocol.onClose">onClose</a></code></li>
<li><code><a title="gameServer.serverCode.factoryAndProtocol.ServerProtocol.onConnect" href="#gameServer.serverCode.factoryAndProtocol.ServerProtocol.onConnect">onConnect</a></code></li>
<li><code><a title="gameServer.serverCode.factoryAndProtocol.ServerProtocol.onMessage" href="#gameServer.serverCode.factoryAndProtocol.ServerProtocol.onMessage">onMessage</a></code></li>
<li><code><a title="gameServer.serverCode.factoryAndProtocol.ServerProtocol.onOpen" href="#gameServer.serverCode.factoryAndProtocol.ServerProtocol.onOpen">onOpen</a></code></li>
<li><code><a title="gameServer.serverCode.factoryAndProtocol.ServerProtocol.sendMessage" href="#gameServer.serverCode.factoryAndProtocol.ServerProtocol.sendMessage">sendMessage</a></code></li>
<li><code><a title="gameServer.serverCode.factoryAndProtocol.ServerProtocol.token" href="#gameServer.serverCode.factoryAndProtocol.ServerProtocol.token">token</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>