<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>settlersPy.server API documentation</title>
<meta name="description" content="Server code for setting up a WebSocket server, handling connections, and verifying
connection details â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>settlersPy.server</code></h1>
</header>
<section id="section-intro">
<p>Server code for setting up a WebSocket server, handling connections, and verifying
connection details.</p>
<p>This code borrows from an earlier project with the CISS ROV Robotics Team</p>
<p>Required 3rd-party libraries:
<code>autobahn</code>
<code>twisted</code></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3.7

&#39;&#39;&#39;
Server code for setting up a WebSocket server, handling connections, and verifying
connection details.

This code borrows from an earlier project with the CISS ROV Robotics Team


Required 3rd-party libraries:
`autobahn`
`twisted`
&#39;&#39;&#39;
import sys
import json
import secrets

# importing the necessary objects
# autobahn does websocket stuff, but relies on twisted
from autobahn.twisted.websocket import \
    WebSocketServerProtocol, WebSocketServerFactory

# twisted does asynchronous code execution needed for websockets
from twisted.python import log
from twisted.internet import reactor

from typing import Callable, Tuple, Union, List

from tools import typeCheck
import mechanics
from message import Message

class ServerProtocol(WebSocketServerProtocol):
    &#39;&#39;&#39;
    Sending a message of &#39;Hi&#39; returns two messages, &#39;Hello&#39; and a json
    that is {&#39;token&#39;: token}

    Sending a message of &#39;history&#39; returns all previously send messages
    &#39;&#39;&#39;

    @property
    def token(self) -&gt; Union[str, None]:
        try:
            return self.__token
        except AttributeError:
            return None

    def onConnect(self, request):

        print(request.path)
        # debug information
        print(&#39;Client connecting &amp; registering: {0}&#39;.format(request.peer))
        clientTypeRequest = request.path

        # process the type of request
        if clientTypeRequest.startswith(&#39;/&#39;):
            # remove the slash if there is one
            clientTypeRequest = clientTypeRequest[1:]

        # tell the factory to remember the connection
        self.__token = self.factory.register(self, clientTypeRequest)

    def onOpen(self):
        print(&#39;WebSocket connection open&#39;)

    def onClose(self, wasClean, code, reason):
        print(&#39;WebSocket connection closed: {0}&#39;.format(reason))

        # tell the factory that this connection is dead
        self.factory.unregister(self)

    def onMessage(self, msg, isBinary):
        msg = msg.decode()

        if msg.lower() == &#39;hi&#39;:
            self.sendMessage(b&#34;Hello&#34;)

            msg = json.dumps({&#39;token&#39;: self.factory.getToken(self)})
            self.sendMessage(msg.encode())

        elif msg == &#39;history&#39;:
            self.factory.sendHistory(self)

        else:
            try:
                obj = json.loads(msg)
                if type(obj) == &#39;str&#39;:
                    raise json.decoder.JSONDecodeError

                m = Message(mechanics.PlayerManager.instance.getPlayer(self.token), obj, self.factory)

                self.factory.callbackHandler(m, self)   
            except json.decoder.JSONDecodeError:
                print(&#34;Error: Invalid JSON:&#34;, msg)


class ServerFactory(WebSocketServerFactory):
    &#39;&#39;&#39;
    Keeps track of all connections and relays data to other clients
    &#39;&#39;&#39;

    def __init__(self, url, f, callbackFunc: Callable[[str, dict], str], 
                 init_msgs: Tuple[str] = (), playerManage: mechanics.PlayerManager = None):
        &#39;&#39;&#39;
        Initializes the class
        Args:
            url (str): has to be in the format of &#34;ws://127.0.0.1:8008&#34;
            f (file): a writable file for logging
        
        The playerManager should be shared with the GameManager
        &#39;&#39;&#39;
        typeCheck(playerManage, mechanics.PlayerManager)

        self.playerManager: mechanics.PlayerManager = playerManage

        self.file = f

        self.callbackFunc = callbackFunc

        self.history = list(init_msgs)

        WebSocketServerFactory.__init__(self, url)
    
    def callbackHandler(self, msg: Message, client: ServerProtocol):
        &#39;&#39;&#39;
        call the callbackFunc to notify the game manager of a new
        message
        &#39;&#39;&#39;
        jsonMsg = self.callbackFunc(msg)
        self.broadcastToAll(jsonMsg)
    
    def getToken(self, client: ServerProtocol) -&gt; str:
        t = client.token
        if t is None:
            raise Exception(&#39;client has not yet registered. This error should not occur ever&#39;)

        return t
    
    def sendHistory(self, client):
        for msg in self.history:
            client.sendMessage(msg.encode())

    def register(self, client: ServerProtocol, clientTypeRequest: str) -&gt; Union[str, None]:
        &#39;&#39;&#39;
        Called by any new connecting client to address
        whether they are a new player or a reconnecting one.

        The request line should be /name/token
        or /name but the first / is removed by onConnect

        In the case that the name is missing the method will
        return `None` and trigger a 400 error. Same goes for if
        a token is given that the server does not know.        
        &#39;&#39;&#39;
        token = None
        name = None

        if len(clientTypeRequest.strip()) == 0:
            print(&#39;name missing&#39;)
            client.sendHttpErrorResponse(404, &#39;Name missing&#39;)
            #client.sendClose()
        
        tmp = clientTypeRequest.strip()
        tmp = tmp.split(&#39;/&#39;)
        l = len(tmp)
        if l == 1:
            name = tmp[0]
        elif l == 2:
            name = tmp[0]
            token = tmp[1]
        else:
            print(&#39;name missing&#39;)
            client.sendHttpErrorResponse(404, &#39;Name missing&#39;)
            #client.sendClose()
            return None
        
        # print(&#39;clientTypeRequest =&#39;, len(clientTypeRequest.strip().split(&#39;/&#39;)))
        
        p: mechanics.Player = None

        if token is None:
            p = mechanics.Player(name, client)
            print(&#34;New player:&#34;, p.token)
            self.playerManager.addPlayer(p)

        if token is not None:
            if token in self.playerManager:
                print(&#34;Reconnecting player:&#34;, token)
                p = self.playerManager.getPlayer(token)
                p.reconnect(client)
            else:
                print(&#34;Unknown token:&#34;, token)
                client.sendHttpErrorResponse(403, &#39;Unknown token given&#39;)
                #client.sendClose()
                return None
                # p = mechanics.Player(name, client)
                # self.pm.addPlayer(p)
        
        return p.token

    def unregister(self, client):
        token = client.token
        if token in self.playerManager:
            print(&#34;Disconnected player:&#34;, token)
            self.playerManager[token].disconnect()
        elif token is None:
            print(&#34;Player disconnected before assigned token:&#34;, token)
        else:
            print(&#34;Disconnected player, but token not found?:&#34;, token)
    
    def broadcastToAll(self, msg: str): # sourceConnection: ServerProtocol
        &#39;&#39;&#39;
        Sends a message of type `str` to all currently connected
        players
        &#39;&#39;&#39;
        self.file.write(msg + &#39;\n&#39;)
        self.file.flush()
        self.history.append(msg)

        encoded = msg.encode()

        for p in self.playerManager:
            if p.isConnected():
                p.connection.sendMessage(encoded)
    
    def broadcastToSome(self, msg: str, tokenList: List[str], writeToHistory: bool = False):
        &#39;&#39;&#39;
        Sends a message of type `str` to all currently connected
        players whose token is found in the list.
        `writeToHistory`  determines whether or not this message should
        be included in the history.
        &#39;&#39;&#39;
        if writeToHistory:
            self.file.write(msg + &#39;\n&#39;)
            self.file.flush()
            self.history.append(msg)
        
        encoded = msg.encode()
        
        for token in tokenList:
            p = self.playerManager.getPlayer(token)
            if p is not None and p.isConnected():
                p.connection.sendMessage(encoded)
        

class Server:

    def __init__(self, ip: str = &#39;127.0.0.1&#39;, port: int = 5000, callbackFunc: Callable[[Message], str] = None, 
                 init_msgs: Tuple[str] = (), playerManage: mechanics.PlayerManager = None):
        &#39;&#39;&#39;
        A class for managing the code for running the server.
        To setup the server, run `s = Server()`,
        and then run `s.run()` to start it.

        Requires keyword argument `callbackFunc` which should
        be of type `Callable[[str, dict], str]`. This is
        for handling incoming messages and should return
        a status update to all clients. The return type
        should be type `str` and be json. The
        arguments are a unique id for each player as a `str`
        and the message from that player as a `dict`
        &#39;&#39;&#39;
        self.ip = ip
        self.port = port

        if not callbackFunc:
            # def dummyFunc(self, d: dict) -&gt; str:
            #     print(&#39;[callbackFunc]&#39;, d)
            #     return &#39;{}&#39;

            # callbackFunc = dummyFunc

            raise TypeError(&#39;Missing keyword argument &#34;callbackFunc&#34; which should be of type &#34;Callable[[dict], str]&#34;&#39;)

        self.file = open(&#39;gameMsgLog.log&#39;, &#39;w&#39;)

        # Setup server factory
        self.server = ServerFactory(u&#39;ws://{}:{}&#39;.format(ip, port), self.file, callbackFunc, init_msgs=init_msgs, playerManage=playerManage)
        self.server.protocol = ServerProtocol

        # setup listening server
        reactor.listenTCP(port, self.server)

    def run(self):
        &#39;&#39;&#39;
        Run the server. This method will not return
        until the server is ended by an Exception like ^C.

        init_msgs are for messages that should be send to the player
        immediately, like the game map for example.
        &#39;&#39;&#39;
        # display debug information to stdout for now
        log.startLogging(sys.stdout)  # TODO: replace with log file (maybe)

        try:
            # start listening for and handling connections
            # task.deferLater(reactor, 1, lambda: [self.server.broadcastToAll(msg) for msg in init_msgs])
            reactor.run()
        except KeyboardInterrupt:
            pass
        finally:
            self.file.close()
            # if logs are sent to a file instead of stdout
            # the file should be closed here with f.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="settlersPy.server.Server"><code class="flex name class">
<span>class <span class="ident">Server</span></span>
<span>(</span><span>ip='127.0.0.1', port=5000, callbackFunc=None, init_msgs=(), playerManage=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A class for managing the code for running the server.
To setup the server, run <code>s = Server()</code>,
and then run <code>s.run()</code> to start it.</p>
<p>Requires keyword argument <code>callbackFunc</code> which should
be of type <code>Callable[[str, dict], str]</code>. This is
for handling incoming messages and should return
a status update to all clients. The return type
should be type <code>str</code> and be json. The
arguments are a unique id for each player as a <code>str</code>
and the message from that player as a <code>dict</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Server:

    def __init__(self, ip: str = &#39;127.0.0.1&#39;, port: int = 5000, callbackFunc: Callable[[Message], str] = None, 
                 init_msgs: Tuple[str] = (), playerManage: mechanics.PlayerManager = None):
        &#39;&#39;&#39;
        A class for managing the code for running the server.
        To setup the server, run `s = Server()`,
        and then run `s.run()` to start it.

        Requires keyword argument `callbackFunc` which should
        be of type `Callable[[str, dict], str]`. This is
        for handling incoming messages and should return
        a status update to all clients. The return type
        should be type `str` and be json. The
        arguments are a unique id for each player as a `str`
        and the message from that player as a `dict`
        &#39;&#39;&#39;
        self.ip = ip
        self.port = port

        if not callbackFunc:
            # def dummyFunc(self, d: dict) -&gt; str:
            #     print(&#39;[callbackFunc]&#39;, d)
            #     return &#39;{}&#39;

            # callbackFunc = dummyFunc

            raise TypeError(&#39;Missing keyword argument &#34;callbackFunc&#34; which should be of type &#34;Callable[[dict], str]&#34;&#39;)

        self.file = open(&#39;gameMsgLog.log&#39;, &#39;w&#39;)

        # Setup server factory
        self.server = ServerFactory(u&#39;ws://{}:{}&#39;.format(ip, port), self.file, callbackFunc, init_msgs=init_msgs, playerManage=playerManage)
        self.server.protocol = ServerProtocol

        # setup listening server
        reactor.listenTCP(port, self.server)

    def run(self):
        &#39;&#39;&#39;
        Run the server. This method will not return
        until the server is ended by an Exception like ^C.

        init_msgs are for messages that should be send to the player
        immediately, like the game map for example.
        &#39;&#39;&#39;
        # display debug information to stdout for now
        log.startLogging(sys.stdout)  # TODO: replace with log file (maybe)

        try:
            # start listening for and handling connections
            # task.deferLater(reactor, 1, lambda: [self.server.broadcastToAll(msg) for msg in init_msgs])
            reactor.run()
        except KeyboardInterrupt:
            pass
        finally:
            self.file.close()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="settlersPy.server.Server.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Run the server. This method will not return
until the server is ended by an Exception like ^C.</p>
<p>init_msgs are for messages that should be send to the player
immediately, like the game map for example.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#39;&#39;&#39;
    Run the server. This method will not return
    until the server is ended by an Exception like ^C.

    init_msgs are for messages that should be send to the player
    immediately, like the game map for example.
    &#39;&#39;&#39;
    # display debug information to stdout for now
    log.startLogging(sys.stdout)  # TODO: replace with log file (maybe)

    try:
        # start listening for and handling connections
        # task.deferLater(reactor, 1, lambda: [self.server.broadcastToAll(msg) for msg in init_msgs])
        reactor.run()
    except KeyboardInterrupt:
        pass
    finally:
        self.file.close()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="settlersPy.server.ServerFactory"><code class="flex name class">
<span>class <span class="ident">ServerFactory</span></span>
<span>(</span><span>url, f, callbackFunc, init_msgs=(), playerManage=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Keeps track of all connections and relays data to other clients</p>
<p>Initializes the class</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>has to be in the format of "ws://127.0.0.1:8008"</dd>
<dt><strong><code>f</code></strong> :&ensp;<code>file</code></dt>
<dd>a writable file for logging</dd>
</dl>
<p>The playerManager should be shared with the GameManager</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServerFactory(WebSocketServerFactory):
    &#39;&#39;&#39;
    Keeps track of all connections and relays data to other clients
    &#39;&#39;&#39;

    def __init__(self, url, f, callbackFunc: Callable[[str, dict], str], 
                 init_msgs: Tuple[str] = (), playerManage: mechanics.PlayerManager = None):
        &#39;&#39;&#39;
        Initializes the class
        Args:
            url (str): has to be in the format of &#34;ws://127.0.0.1:8008&#34;
            f (file): a writable file for logging
        
        The playerManager should be shared with the GameManager
        &#39;&#39;&#39;
        typeCheck(playerManage, mechanics.PlayerManager)

        self.playerManager: mechanics.PlayerManager = playerManage

        self.file = f

        self.callbackFunc = callbackFunc

        self.history = list(init_msgs)

        WebSocketServerFactory.__init__(self, url)
    
    def callbackHandler(self, msg: Message, client: ServerProtocol):
        &#39;&#39;&#39;
        call the callbackFunc to notify the game manager of a new
        message
        &#39;&#39;&#39;
        jsonMsg = self.callbackFunc(msg)
        self.broadcastToAll(jsonMsg)
    
    def getToken(self, client: ServerProtocol) -&gt; str:
        t = client.token
        if t is None:
            raise Exception(&#39;client has not yet registered. This error should not occur ever&#39;)

        return t
    
    def sendHistory(self, client):
        for msg in self.history:
            client.sendMessage(msg.encode())

    def register(self, client: ServerProtocol, clientTypeRequest: str) -&gt; Union[str, None]:
        &#39;&#39;&#39;
        Called by any new connecting client to address
        whether they are a new player or a reconnecting one.

        The request line should be /name/token
        or /name but the first / is removed by onConnect

        In the case that the name is missing the method will
        return `None` and trigger a 400 error. Same goes for if
        a token is given that the server does not know.        
        &#39;&#39;&#39;
        token = None
        name = None

        if len(clientTypeRequest.strip()) == 0:
            print(&#39;name missing&#39;)
            client.sendHttpErrorResponse(404, &#39;Name missing&#39;)
            #client.sendClose()
        
        tmp = clientTypeRequest.strip()
        tmp = tmp.split(&#39;/&#39;)
        l = len(tmp)
        if l == 1:
            name = tmp[0]
        elif l == 2:
            name = tmp[0]
            token = tmp[1]
        else:
            print(&#39;name missing&#39;)
            client.sendHttpErrorResponse(404, &#39;Name missing&#39;)
            #client.sendClose()
            return None
        
        # print(&#39;clientTypeRequest =&#39;, len(clientTypeRequest.strip().split(&#39;/&#39;)))
        
        p: mechanics.Player = None

        if token is None:
            p = mechanics.Player(name, client)
            print(&#34;New player:&#34;, p.token)
            self.playerManager.addPlayer(p)

        if token is not None:
            if token in self.playerManager:
                print(&#34;Reconnecting player:&#34;, token)
                p = self.playerManager.getPlayer(token)
                p.reconnect(client)
            else:
                print(&#34;Unknown token:&#34;, token)
                client.sendHttpErrorResponse(403, &#39;Unknown token given&#39;)
                #client.sendClose()
                return None
                # p = mechanics.Player(name, client)
                # self.pm.addPlayer(p)
        
        return p.token

    def unregister(self, client):
        token = client.token
        if token in self.playerManager:
            print(&#34;Disconnected player:&#34;, token)
            self.playerManager[token].disconnect()
        elif token is None:
            print(&#34;Player disconnected before assigned token:&#34;, token)
        else:
            print(&#34;Disconnected player, but token not found?:&#34;, token)
    
    def broadcastToAll(self, msg: str): # sourceConnection: ServerProtocol
        &#39;&#39;&#39;
        Sends a message of type `str` to all currently connected
        players
        &#39;&#39;&#39;
        self.file.write(msg + &#39;\n&#39;)
        self.file.flush()
        self.history.append(msg)

        encoded = msg.encode()

        for p in self.playerManager:
            if p.isConnected():
                p.connection.sendMessage(encoded)
    
    def broadcastToSome(self, msg: str, tokenList: List[str], writeToHistory: bool = False):
        &#39;&#39;&#39;
        Sends a message of type `str` to all currently connected
        players whose token is found in the list.
        `writeToHistory`  determines whether or not this message should
        be included in the history.
        &#39;&#39;&#39;
        if writeToHistory:
            self.file.write(msg + &#39;\n&#39;)
            self.file.flush()
            self.history.append(msg)
        
        encoded = msg.encode()
        
        for token in tokenList:
            p = self.playerManager.getPlayer(token)
            if p is not None and p.isConnected():
                p.connection.sendMessage(encoded)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>autobahn.twisted.websocket.WebSocketServerFactory</li>
<li>autobahn.twisted.websocket.WebSocketAdapterFactory</li>
<li>autobahn.websocket.protocol.WebSocketServerFactory</li>
<li>autobahn.websocket.protocol.WebSocketFactory</li>
<li>twisted.internet.protocol.ServerFactory</li>
<li>twisted.internet.protocol.Factory</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="settlersPy.server.ServerFactory.broadcastToAll"><code class="name flex">
<span>def <span class="ident">broadcastToAll</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<section class="desc"><p>Sends a message of type <code>str</code> to all currently connected
players</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def broadcastToAll(self, msg: str): # sourceConnection: ServerProtocol
    &#39;&#39;&#39;
    Sends a message of type `str` to all currently connected
    players
    &#39;&#39;&#39;
    self.file.write(msg + &#39;\n&#39;)
    self.file.flush()
    self.history.append(msg)

    encoded = msg.encode()

    for p in self.playerManager:
        if p.isConnected():
            p.connection.sendMessage(encoded)</code></pre>
</details>
</dd>
<dt id="settlersPy.server.ServerFactory.broadcastToSome"><code class="name flex">
<span>def <span class="ident">broadcastToSome</span></span>(<span>self, msg, tokenList, writeToHistory=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Sends a message of type <code>str</code> to all currently connected
players whose token is found in the list.
<code>writeToHistory</code>
determines whether or not this message should
be included in the history.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def broadcastToSome(self, msg: str, tokenList: List[str], writeToHistory: bool = False):
    &#39;&#39;&#39;
    Sends a message of type `str` to all currently connected
    players whose token is found in the list.
    `writeToHistory`  determines whether or not this message should
    be included in the history.
    &#39;&#39;&#39;
    if writeToHistory:
        self.file.write(msg + &#39;\n&#39;)
        self.file.flush()
        self.history.append(msg)
    
    encoded = msg.encode()
    
    for token in tokenList:
        p = self.playerManager.getPlayer(token)
        if p is not None and p.isConnected():
            p.connection.sendMessage(encoded)</code></pre>
</details>
</dd>
<dt id="settlersPy.server.ServerFactory.callbackHandler"><code class="name flex">
<span>def <span class="ident">callbackHandler</span></span>(<span>self, msg, client)</span>
</code></dt>
<dd>
<section class="desc"><p>call the callbackFunc to notify the game manager of a new
message</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def callbackHandler(self, msg: Message, client: ServerProtocol):
    &#39;&#39;&#39;
    call the callbackFunc to notify the game manager of a new
    message
    &#39;&#39;&#39;
    jsonMsg = self.callbackFunc(msg)
    self.broadcastToAll(jsonMsg)</code></pre>
</details>
</dd>
<dt id="settlersPy.server.ServerFactory.getToken"><code class="name flex">
<span>def <span class="ident">getToken</span></span>(<span>self, client)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getToken(self, client: ServerProtocol) -&gt; str:
    t = client.token
    if t is None:
        raise Exception(&#39;client has not yet registered. This error should not occur ever&#39;)

    return t</code></pre>
</details>
</dd>
<dt id="settlersPy.server.ServerFactory.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>self, client, clientTypeRequest)</span>
</code></dt>
<dd>
<section class="desc"><p>Called by any new connecting client to address
whether they are a new player or a reconnecting one.</p>
<p>The request line should be /name/token
or /name but the first / is removed by onConnect</p>
<p>In the case that the name is missing the method will
return <code>None</code> and trigger a 400 error. Same goes for if
a token is given that the server does not know.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register(self, client: ServerProtocol, clientTypeRequest: str) -&gt; Union[str, None]:
    &#39;&#39;&#39;
    Called by any new connecting client to address
    whether they are a new player or a reconnecting one.

    The request line should be /name/token
    or /name but the first / is removed by onConnect

    In the case that the name is missing the method will
    return `None` and trigger a 400 error. Same goes for if
    a token is given that the server does not know.        
    &#39;&#39;&#39;
    token = None
    name = None

    if len(clientTypeRequest.strip()) == 0:
        print(&#39;name missing&#39;)
        client.sendHttpErrorResponse(404, &#39;Name missing&#39;)
        #client.sendClose()
    
    tmp = clientTypeRequest.strip()
    tmp = tmp.split(&#39;/&#39;)
    l = len(tmp)
    if l == 1:
        name = tmp[0]
    elif l == 2:
        name = tmp[0]
        token = tmp[1]
    else:
        print(&#39;name missing&#39;)
        client.sendHttpErrorResponse(404, &#39;Name missing&#39;)
        #client.sendClose()
        return None
    
    # print(&#39;clientTypeRequest =&#39;, len(clientTypeRequest.strip().split(&#39;/&#39;)))
    
    p: mechanics.Player = None

    if token is None:
        p = mechanics.Player(name, client)
        print(&#34;New player:&#34;, p.token)
        self.playerManager.addPlayer(p)

    if token is not None:
        if token in self.playerManager:
            print(&#34;Reconnecting player:&#34;, token)
            p = self.playerManager.getPlayer(token)
            p.reconnect(client)
        else:
            print(&#34;Unknown token:&#34;, token)
            client.sendHttpErrorResponse(403, &#39;Unknown token given&#39;)
            #client.sendClose()
            return None
            # p = mechanics.Player(name, client)
            # self.pm.addPlayer(p)
    
    return p.token</code></pre>
</details>
</dd>
<dt id="settlersPy.server.ServerFactory.sendHistory"><code class="name flex">
<span>def <span class="ident">sendHistory</span></span>(<span>self, client)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sendHistory(self, client):
    for msg in self.history:
        client.sendMessage(msg.encode())</code></pre>
</details>
</dd>
<dt id="settlersPy.server.ServerFactory.unregister"><code class="name flex">
<span>def <span class="ident">unregister</span></span>(<span>self, client)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister(self, client):
    token = client.token
    if token in self.playerManager:
        print(&#34;Disconnected player:&#34;, token)
        self.playerManager[token].disconnect()
    elif token is None:
        print(&#34;Player disconnected before assigned token:&#34;, token)
    else:
        print(&#34;Disconnected player, but token not found?:&#34;, token)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="settlersPy.server.ServerProtocol"><code class="flex name class">
<span>class <span class="ident">ServerProtocol</span></span>
</code></dt>
<dd>
<section class="desc"><p>Sending a message of 'Hi' returns two messages, 'Hello' and a json
that is {'token': token}</p>
<p>Sending a message of 'history' returns all previously send messages</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServerProtocol(WebSocketServerProtocol):
    &#39;&#39;&#39;
    Sending a message of &#39;Hi&#39; returns two messages, &#39;Hello&#39; and a json
    that is {&#39;token&#39;: token}

    Sending a message of &#39;history&#39; returns all previously send messages
    &#39;&#39;&#39;

    @property
    def token(self) -&gt; Union[str, None]:
        try:
            return self.__token
        except AttributeError:
            return None

    def onConnect(self, request):

        print(request.path)
        # debug information
        print(&#39;Client connecting &amp; registering: {0}&#39;.format(request.peer))
        clientTypeRequest = request.path

        # process the type of request
        if clientTypeRequest.startswith(&#39;/&#39;):
            # remove the slash if there is one
            clientTypeRequest = clientTypeRequest[1:]

        # tell the factory to remember the connection
        self.__token = self.factory.register(self, clientTypeRequest)

    def onOpen(self):
        print(&#39;WebSocket connection open&#39;)

    def onClose(self, wasClean, code, reason):
        print(&#39;WebSocket connection closed: {0}&#39;.format(reason))

        # tell the factory that this connection is dead
        self.factory.unregister(self)

    def onMessage(self, msg, isBinary):
        msg = msg.decode()

        if msg.lower() == &#39;hi&#39;:
            self.sendMessage(b&#34;Hello&#34;)

            msg = json.dumps({&#39;token&#39;: self.factory.getToken(self)})
            self.sendMessage(msg.encode())

        elif msg == &#39;history&#39;:
            self.factory.sendHistory(self)

        else:
            try:
                obj = json.loads(msg)
                if type(obj) == &#39;str&#39;:
                    raise json.decoder.JSONDecodeError

                m = Message(mechanics.PlayerManager.instance.getPlayer(self.token), obj, self.factory)

                self.factory.callbackHandler(m, self)   
            except json.decoder.JSONDecodeError:
                print(&#34;Error: Invalid JSON:&#34;, msg)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>autobahn.twisted.websocket.WebSocketServerProtocol</li>
<li>autobahn.twisted.websocket.WebSocketAdapterProtocol</li>
<li>twisted.internet.protocol.Protocol</li>
<li>twisted.internet.protocol.BaseProtocol</li>
<li>autobahn.websocket.protocol.WebSocketServerProtocol</li>
<li>autobahn.websocket.protocol.WebSocketProtocol</li>
<li>autobahn.util.ObservableMixin</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="settlersPy.server.ServerProtocol.token"><code class="name">var <span class="ident">token</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def token(self) -&gt; Union[str, None]:
    try:
        return self.__token
    except AttributeError:
        return None</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="settlersPy.server.ServerProtocol.onClose"><code class="name flex">
<span>def <span class="ident">onClose</span></span>(<span>self, wasClean, code, reason)</span>
</code></dt>
<dd>
<section class="desc"><p>Implements :func:<code>autobahn.websocket.interfaces.IWebSocketChannel.onClose</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onClose(self, wasClean, code, reason):
    print(&#39;WebSocket connection closed: {0}&#39;.format(reason))

    # tell the factory that this connection is dead
    self.factory.unregister(self)</code></pre>
</details>
</dd>
<dt id="settlersPy.server.ServerProtocol.onConnect"><code class="name flex">
<span>def <span class="ident">onConnect</span></span>(<span>self, request)</span>
</code></dt>
<dd>
<section class="desc"><p>Callback fired during WebSocket opening handshake when new WebSocket client
connection is about to be established.</p>
<p>When you want to accept the connection, return the accepted protocol
from list of WebSocket (sub)protocols provided by client or <code>None</code> to
speak no specific one or when the client protocol list was empty.</p>
<p>You may also return a pair of <code>(protocol, headers)</code> to send additional
HTTP headers, with <code>headers</code> being a dictionary of key-values.</p>
<p>Throw :class:<code>autobahn.websocket.types.ConnectionDeny</code> when you don't want
to accept the WebSocket connection request.</p>
<p>:param request: WebSocket connection request information.
:type request: instance of :class:<code>autobahn.websocket.protocol.ConnectionRequest</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onConnect(self, request):

    print(request.path)
    # debug information
    print(&#39;Client connecting &amp; registering: {0}&#39;.format(request.peer))
    clientTypeRequest = request.path

    # process the type of request
    if clientTypeRequest.startswith(&#39;/&#39;):
        # remove the slash if there is one
        clientTypeRequest = clientTypeRequest[1:]

    # tell the factory to remember the connection
    self.__token = self.factory.register(self, clientTypeRequest)</code></pre>
</details>
</dd>
<dt id="settlersPy.server.ServerProtocol.onMessage"><code class="name flex">
<span>def <span class="ident">onMessage</span></span>(<span>self, msg, isBinary)</span>
</code></dt>
<dd>
<section class="desc"><p>Implements :func:<code>autobahn.websocket.interfaces.IWebSocketChannel.onMessage</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onMessage(self, msg, isBinary):
    msg = msg.decode()

    if msg.lower() == &#39;hi&#39;:
        self.sendMessage(b&#34;Hello&#34;)

        msg = json.dumps({&#39;token&#39;: self.factory.getToken(self)})
        self.sendMessage(msg.encode())

    elif msg == &#39;history&#39;:
        self.factory.sendHistory(self)

    else:
        try:
            obj = json.loads(msg)
            if type(obj) == &#39;str&#39;:
                raise json.decoder.JSONDecodeError

            m = Message(mechanics.PlayerManager.instance.getPlayer(self.token), obj, self.factory)

            self.factory.callbackHandler(m, self)   
        except json.decoder.JSONDecodeError:
            print(&#34;Error: Invalid JSON:&#34;, msg)</code></pre>
</details>
</dd>
<dt id="settlersPy.server.ServerProtocol.onOpen"><code class="name flex">
<span>def <span class="ident">onOpen</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Implements :func:<code>autobahn.websocket.interfaces.IWebSocketChannel.onOpen</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onOpen(self):
    print(&#39;WebSocket connection open&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="settlersPy" href="index.html">settlersPy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="settlersPy.server.Server" href="#settlersPy.server.Server">Server</a></code></h4>
<ul class="">
<li><code><a title="settlersPy.server.Server.run" href="#settlersPy.server.Server.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="settlersPy.server.ServerFactory" href="#settlersPy.server.ServerFactory">ServerFactory</a></code></h4>
<ul class="two-column">
<li><code><a title="settlersPy.server.ServerFactory.broadcastToAll" href="#settlersPy.server.ServerFactory.broadcastToAll">broadcastToAll</a></code></li>
<li><code><a title="settlersPy.server.ServerFactory.broadcastToSome" href="#settlersPy.server.ServerFactory.broadcastToSome">broadcastToSome</a></code></li>
<li><code><a title="settlersPy.server.ServerFactory.callbackHandler" href="#settlersPy.server.ServerFactory.callbackHandler">callbackHandler</a></code></li>
<li><code><a title="settlersPy.server.ServerFactory.getToken" href="#settlersPy.server.ServerFactory.getToken">getToken</a></code></li>
<li><code><a title="settlersPy.server.ServerFactory.register" href="#settlersPy.server.ServerFactory.register">register</a></code></li>
<li><code><a title="settlersPy.server.ServerFactory.sendHistory" href="#settlersPy.server.ServerFactory.sendHistory">sendHistory</a></code></li>
<li><code><a title="settlersPy.server.ServerFactory.unregister" href="#settlersPy.server.ServerFactory.unregister">unregister</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="settlersPy.server.ServerProtocol" href="#settlersPy.server.ServerProtocol">ServerProtocol</a></code></h4>
<ul class="">
<li><code><a title="settlersPy.server.ServerProtocol.onClose" href="#settlersPy.server.ServerProtocol.onClose">onClose</a></code></li>
<li><code><a title="settlersPy.server.ServerProtocol.onConnect" href="#settlersPy.server.ServerProtocol.onConnect">onConnect</a></code></li>
<li><code><a title="settlersPy.server.ServerProtocol.onMessage" href="#settlersPy.server.ServerProtocol.onMessage">onMessage</a></code></li>
<li><code><a title="settlersPy.server.ServerProtocol.onOpen" href="#settlersPy.server.ServerProtocol.onOpen">onOpen</a></code></li>
<li><code><a title="settlersPy.server.ServerProtocol.token" href="#settlersPy.server.ServerProtocol.token">token</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>